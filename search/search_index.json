{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Geospatial Coding Hub: The Definitive Guide to Modern Spatial Science","text":"<p>Welcome to the Geospatial Coding Hub, a comprehensive, professional-grade platform designed to transition environmental scientists, urban planners, and GIS analysts into the world of high-performance spatial data science. This resource is not just a collection of code snippets; it is a foundational curriculum built to address the complexities of the 21st-century spatial data landscape.</p>"},{"location":"#evolution-of-geospatial-science-from-cartography-to-computation","title":"\ud83c\udfdb\ufe0f Evolution of Geospatial Science: From Cartography to Computation","text":"<p>The history of Geographic Information Systems (GIS) is a journey of increasing abstraction and computational power. In the early days, GIS was synonymous with physical map-making. With the advent of computer-aided design (CAD) and early desktop GIS software in the 1980s and 90s, the focus shifted to digital storage and the \"layer\" cake model of geographic information.</p> <p>However, we are now in the midst of the Third Wave of GIS: The era of Geospatial Data Science. This wave is characterized by:</p> <ol> <li>Big Data: The sheer volume of satellite imagery (Petabytes per day) has outpaced the capability of local hardware.</li> <li>Machine Learning: We no longer manually digitize every building; we train neural networks to do it for us.</li> <li>Cloud-Native Architectures: Data is moving away from local shapefiles toward Cloud Optimized GeoTIFFs (COG) and SpatioTemporal Asset Catalogs (STAC).</li> </ol>"},{"location":"#the-code-first-philosophy","title":"\ud83d\ude80 The Code-First Philosophy","text":"<p>Why code? Traditional GUI-based GIS software (like ArcGIS or QGIS) is excellent for production-quality cartography. But for research, modeling, and large-scale analysis, it has several critical drawbacks that coding elegantly solves:</p>"},{"location":"#1-the-transparency-gap","title":"1. The Transparency Gap","text":"<p>In a GUI, a complex analysis is a series of clicks. A year later, it is almost impossible to remember exactly which buttons were pressed or what parameters were set. In the Geospatial Coding Hub, every analysis is a script. It is a living document of your logic, transparent to both you and your collaborators.</p>"},{"location":"#2-algorithmic-flexibility","title":"2. Algorithmic Flexibility","text":"<p>Software developers must make assumptions about what users want. If you need a custom spatial weight matrix or a unique hybrid classification algorithm that doesn't exist in a dropdown menu, you are stuck. Coding allows you to build the tool you need from first principles.</p>"},{"location":"#3-high-performance-scaling","title":"3. High-Performance Scaling","text":"<p>Processing 10,000 satellite images locally would crash most workstations. By using tools like Google Earth Engine (GEE) or Dask, we distribute that workload across thousands of servers.</p>"},{"location":"#core-knowledge-pillars","title":"\ud83d\uddfa\ufe0f Core Knowledge Pillars","text":"- :material-language-python:{ .lg .middle } **Python for GIS**      ---      Automate spatial analysis using GeoPandas, Rasterio, and Shapely.      [:octicons-arrow-right-24: Dive Deeper](python_gis.md)  - :material-web:{ .lg .middle } **Cloud Computing**      ---      Scale your analysis to a planetary level with Google Earth Engine (GEE).      [:octicons-arrow-right-24: Dive Deeper](gee_geemap.md)  - :material-chart-line:{ .lg .middle } **Machine Learning**      ---      Implement Random Forest, CNNs, and Clustering for LULC and spatial prediction.      [:octicons-arrow-right-24: Dive Deeper](ml_geospatial.md)  - :material-book-open-variant:{ .lg .middle } **Guided Tutorials**      ---      Step-by-step curricula for all skill levels.      [:octicons-arrow-right-24: Dive Deeper](tutorials.md)"},{"location":"#comparison-the-traditional-vs-modern-workflow","title":"\ud83d\udcca Comparison: The Traditional vs. Modern Workflow","text":"<p>Understanding where we come from helps us appreciate where we are going. Below is a detailed technical comparison of these two worlds.</p> Feature Legacy Desktop GIS Modern Geospatial Coding Data Format Shapefiles, GDB (local, proprietary) COG, Zarr, STAC (cloud-native, open) Logic Storage Inaccessible binary project files Open-source Scripts (Python/R/Java) Reproducibility Poor (\"The manual click burden\") Perfect (Git-tracked code history) Hardware High-end GPU workstations Browser-based (Jupyter / Colab) Scalability Vertical (Larger RAM) Horizontal (Distributed clusters) Visualization Static Maps (.pdf, .png) Interactive Web Dashboards (Dash, Streamlit)"},{"location":"#how-to-navigate-this-hub","title":"\ud83d\udee0\ufe0f How to Navigate This Hub","text":"<p>This repository is structured as a tiered learning path.</p>"},{"location":"#step-1-establish-the-environment","title":"Step 1: Establish the Environment","text":"<p>Geospatial libraries are notorious for installation conflicts. We highly recommend starting with our Environment Guide, which uses <code>mamba</code> to ensure a stable, production-ready setup.</p>"},{"location":"#step-2-master-the-vector-foundation","title":"Step 2: Master the Vector Foundation","text":"<p>Vectors are the \"atoms\" of GIS. You will learn to manipulate points, lines, and polygons not as \"drawings,\" but as mathematical objects.</p>"},{"location":"#step-3-tackle-the-raster-challenge","title":"Step 3: Tackle the Raster Challenge","text":"<p>Understand the grid. We move beyond simple visualization to spectral math, principal component analysis (PCA) of bands, and spatial interpolation.</p>"},{"location":"#step-4-graduate-to-the-cloud","title":"Step 4: Graduate to the Cloud","text":"<p>Once you understand the math, apply it to the world. Using GEE and <code>geemap</code>, you will perform analysis on global scales.</p>"},{"location":"#future-horizons","title":"\ud83d\udcc8 Future Horizons","text":"<p>The field of Geospatial Science is rapidly evolving. We are actively adding modules on:</p> <ul> <li>SAR Analysis: Using Radar data (Sentinel-1) for flood mapping and forest monitoring.</li> <li>UAV Photogrammetry: Processing drone data with Python.</li> <li>Digital Twins: Creating 3D representations of urban environments using LiDAR and Mesh data.</li> </ul> <p>Community Driven</p> <p>This hub is meant to be a living resource. If you encounter a bug in a code block or wish to see a tutorial on a specific niche (e.g., Hydrological Modeling), please use the Edit icon in the top right to suggest a change!</p>"},{"location":"#final-thoughts","title":"\ud83c\udfc6 Final Thoughts","text":"<p>The goal of this hub is to empower you to become a Geospatial Architect. We don't just want you to make a map; we want you to build a system that analyzes the world.</p> <p>Start the Journey: Python for GIS \u00bb{ .md-button .md-button--primary }</p>"},{"location":"data_sources/","title":"Modern Geospatial Data Sources &amp; Formats","text":"<p>The landscape of geospatial data has shifted from local \"file-based\" workflows to \"cloud-native\" architectures. Instead of downloading gigabytes of zip files, we now query metadata and stream only the pixels or features we need.</p>"},{"location":"data_sources/#1-stac-spatiotemporal-asset-catalog","title":"\ud83d\udef0\ufe0f 1. STAC (SpatioTemporal Asset Catalog)","text":"<p>STAC is a specification that provides a common language to describe geospatial information. It makes it easier to index and discover data from multiple providers (NASA, ESA, Planet, etc.).</p>"},{"location":"data_sources/#why-use-stac","title":"Why use STAC?","text":"<ul> <li>Searchability: Find data by time, location, and property (e.g., \"Cloud cover &lt; 10%\").</li> <li>Asset Links: Direct URLs to files (COGs, metadata, thumbnails).</li> <li>Interoperability: The same code works for Sentinel-2, Landsat, and commercial data.</li> </ul>"},{"location":"data_sources/#python-example-searching-for-data","title":"\ud83d\udc0d Python Example: Searching for Data","text":"<p>Using <code>pystac-client</code> to find Sentinel-2 images over a specific area.</p> <pre><code>from pystac_client import Client\n\n# Microsoft Planetary Computer STAC API\ncatalog = Client.open(\"https://planetarycomputer.microsoft.com/api/stac/v1\")\n\n# Define our area of interest (Bhubaneswar, India)\narea_of_interest = {\n    \"type\": \"Point\",\n    \"coordinates\": [85.8245, 20.2961]\n}\n\n# Search for Sentinel-2 data in 2023 with low cloud cover\nsearch = catalog.search(\n    collections=[\"sentinel-2-l2a\"],\n    intersects=area_of_interest,\n    datetime=\"2023-01-01/2023-12-31\",\n    query={\"eo:cloud_cover\": {\"lt\": 5}}\n)\n\nitems = search.item_collection()\nprint(f\"Found {len(items)} items matching your criteria.\")\n\n# Access the first item's assets\nfor asset_key, asset in items[0].assets.items():\n    print(f\"- {asset_key}: {asset.title}\")\n</code></pre>"},{"location":"data_sources/#2-cloud-optimized-geotiff-cog","title":"\ud83d\uddbc\ufe0f 2. Cloud Optimized GeoTIFF (COG)","text":"<p>A COG is a regular GeoTIFF file but with a specific internal organization that allows for \"HTTP Range Requests.\" This means you can read just a small portion of a huge image without downloading the whole thing.</p>"},{"location":"data_sources/#key-features","title":"Key Features","text":"<ul> <li>Internal Tiling: Data is stored in small chunks.</li> <li>Overviews (Pyramids): Pre-rendered low-resolution versions for fast viewing.</li> <li>Streaming: Works perfectly with <code>rasterio</code> and <code>stackstac</code>.</li> </ul>"},{"location":"data_sources/#python-example-streaming-a-cog","title":"\ud83d\udc0d Python Example: Streaming a COG","text":"<pre><code>import stackstac\nimport pystac_client\n\n# Get a STAC item (from the previous example)\nitem = items[0]\n\n# Load only the Red and NIR bands into an Xarray DataArray\n# stackstac handles the \"lazy loading\" from the cloud\nds = stackstac.stack(item, assets=[\"red\", \"nir\"])\n\nprint(ds)\n# The data isn't downloaded yet! It's just metadata until you call .compute()\n</code></pre>"},{"location":"data_sources/#3-modern-vector-formats-geoparquet-flatgeobuf","title":"\ud83e\uddec 3. Modern Vector Formats: GeoParquet &amp; FlatGeobuf","text":"<p>Traditional Shapefiles are outdated (limitations on file size, column names, and multi-file structure). Modern alternatives are designed for the cloud.</p> Format Best For Why? GeoParquet Big Data / Analytics Columnar storage, high compression, works with Spark/DuckDB. FlatGeobuf Web Mapping / Streaming Fast spatial indexing, can be read incrementally over HTTP. GeoJSON Small Data / Web Easy to read, but slow for large datasets."},{"location":"data_sources/#python-example-geoparquet","title":"\ud83d\udc0d Python Example: GeoParquet","text":"<pre><code>import geopandas as gpd\n\n# Reading a GeoParquet file from a URL\nurl = \"https://example.com/data.parquet\"\ngdf = gpd.read_parquet(url)\n\n# Writing to GeoParquet (requires pyarrow)\ngdf.to_parquet(\"my_data.parquet\", compression='snappy')\n</code></pre>"},{"location":"data_sources/#4-multidimensional-data-zarr","title":"\ud83e\uddca 4. Multidimensional Data: Zarr","text":"<p>For climate data or time-series (like 50 years of daily rainfall), Zarr is the cloud-native alternative to NetCDF/HDF5.</p> <ul> <li>Chunked: Allows parallel reads across many threads.</li> <li>Scalable: Stores data in chunks as separate files or objects in S3/Azure Blob.</li> <li>Integration: Native support in <code>Xarray</code>.</li> </ul>"},{"location":"data_sources/#python-example-zarr","title":"\ud83d\udc0d Python Example: Zarr","text":"<pre><code>import xarray as xr\n\n# Open a Zarr dataset from Google Cloud Storage\nds = xr.open_zarr(\"gs://cmip6/CMIP6/CMIP/AS-RCEC/TaiESM1/historical/r1i1p1f1/Amon/tas/gn/v20200225/\")\nprint(ds)\n</code></pre>"},{"location":"data_sources/#summary-table-what-to-use","title":"\ud83d\udcda Summary Table: What to use?","text":"Use Case Recommended Format Tool to Use Finding Imagery STAC <code>pystac-client</code> Satellite Pixels COG <code>stackstac</code>, <code>rasterio</code> Big Vector Data GeoParquet <code>geopandas</code>, <code>dask-geopandas</code> Weather/Climate Zarr <code>xarray</code>, <code>zarr</code> Web App Streaming MVT (Vector Tiles) <code>tippecanoe</code>, <code>maplibre</code> <p>Workflow Tip</p> <p>Always try to use STAC as your entry point for data. It abstracts away the complexity of where files are stored and how they are named.</p> <p>Next: Cloud Computing with GEE &amp; Geemap \u00bb{ .md-button .md-button--primary }</p>"},{"location":"gee_geemap/","title":"Google Earth Engine &amp; Geemap: The Cloud Frontier","text":"<p>Google Earth Engine (GEE) represents a fundamental shift in geospatial analysis. Moving from \"data-download\" to \"code-to-data,\" it provides a multi-petabyte catalog of satellite imagery and the computational power to process it across thousands of cores. This guide explores the architecture of the GEE ecosystem and how to master it via Python using <code>geemap</code>.</p>"},{"location":"gee_geemap/#section-1-the-gee-architecture-client-vs-server","title":"\ud83c\udfdb\ufe0f Section 1: The GEE Architecture (Client vs. Server)","text":"<p>One of the steepest learning curves in GEE is understanding why a standard Python <code>for</code> loop or <code>if</code> statement doesn't work on Earth Engine objects.</p>"},{"location":"gee_geemap/#11-client-side-vs-server-side","title":"1.1 Client-Side vs. Server-Side","text":"<ul> <li>Client-Side (Python/JS): This is your browser or your Jupyter notebook. It handles the interface and instructions.</li> <li>Server-Side (Google): This is where the actual images are stored.</li> <li>The Bridge: When you write <code>image.add(1)</code>, you aren't adding one to a number in RAM. You are sending a Instruction (JSON) to Google saying: \"Find this image in your database and add one to every pixel.\"</li> </ul>"},{"location":"gee_geemap/#12-deferred-execution-lazy-loading","title":"1.2 Deferred Execution (Lazy Loading)","text":"<p>Nothing actually happens until you request a result (e.g., <code>Map.addLayer</code>, <code>getInfo()</code>, or <code>Export</code>). This allows GEE to only process the specific pixels visible on your screen at a specific zoom level.</p>"},{"location":"gee_geemap/#section-2-mastering-imagecollections-filtering","title":"\ud83d\udef0\ufe0f Section 2: Mastering ImageCollections &amp; Filtering","text":"<p>An <code>ImageCollection</code> is a stack of images. Learning to filter this stack efficiently is the key to global analysis.</p> Advanced FilteringReducers: Turning Pixels into Stats <pre><code>import ee\nimport geemap\n\n# Define a point of interest\nroi = ee.Geometry.Point([85.8, 20.3])\n\n# Load Sentinel-2 Collection (Bottom of Atmosphere)\ns2_collection = ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\") \\\n    .filterBounds(roi) \\\n    .filterDate('2023-01-01', '2023-06-30') \\\n    .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10)) \\\n    .sort('CLOUDY_PIXEL_PERCENTAGE')\n\nprint(f\"Number of clear images found: {s2_collection.size().getInfo()}\")\n</code></pre> <p>Reducers allow you to aggregate data across space or time.</p> <pre><code># Temporal Reducer: Create a Median Composite (Cloud-free look)\nmedian_image = s2_collection.median()\n\n# Spatial Reducer: Calculate mean temperature for a district\ntemp_collection = ee.ImageCollection(\"MODIS/061/MOD11A1\")\nmean_temp = temp_collection.mean().reduceRegion(\n    reducer=ee.Reducer.mean(),\n    geometry=roi,\n    scale=1000\n)\n</code></pre>"},{"location":"gee_geemap/#section-3-time-series-analysis-change-detection","title":"\ud83c\udf0d Section 3: Time-Series Analysis &amp; Change Detection","text":"<p>One of GEE's greatest strengths is analyzing changes over decades.</p>"},{"location":"gee_geemap/#31-map-and-iterate","title":"3.1 Map and Iterate","text":"<p>In Python, we use <code>.map()</code> to apply a function to every image in a collection.</p> <pre><code>def calculate_indices(image):\n    # Calculate NDVI and NDWI simultaneously\n    ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI')\n    ndwi = image.normalizedDifference(['B3', 'B8']).rename('NDWI')\n    return image.addBands([ndvi, ndwi])\n\n# Apply to the whole collection\nprocessed_collection = s2_collection.map(calculate_indices)\n</code></pre>"},{"location":"gee_geemap/#32-time-series-plotting-with-geemap","title":"3.2 Time-Series Plotting with Geemap","text":"<p><code>geemap</code> makes it incredibly easy to create interactive charts that would require hundreds of lines of code in JavaScript.</p> <pre><code># Create a chart of NDVI over time\ngeemap.chart_image_collection_by_day(\n    processed_collection, \n    'NDVI', \n    region=roi, \n    scale=30\n)\n</code></pre>"},{"location":"gee_geemap/#section-4-exporting-publishing","title":"\ud83d\uddbc\ufe0f Section 4: Exporting &amp; Publishing","text":""},{"location":"gee_geemap/#41-exporting-to-local-drive","title":"4.1 Exporting to Local Drive","text":"<p>Standard GEE exports to Google Drive. <code>geemap</code> allows for direct downloading of small-to-medium datasets.</p> <pre><code># Download as GeoTIFF directly to your Downloads folder\ngeemap.ee_export_image(\n    median_image.select(['B4', 'B3', 'B2']), \n    filename=\"my_satellite_export.tif\", \n    scale=30, \n    region=roi\n)\n</code></pre>"},{"location":"gee_geemap/#42-building-interactive-web-apps","title":"4.2 Building Interactive Web Apps","text":"<p>You can convert a Jupyter notebook into a full web application using Streamlit + geemap.</p> <pre><code>import streamlit as st\nimport geemap.foliumap as geemap\n\nst.title(\"Sentinel-2 Explorer\")\nm = geemap.Map()\nm.add_basemap(\"HYBRID\")\nm.to_streamlit()\n</code></pre>"},{"location":"gee_geemap/#advanced-geemap-utilities","title":"\ud83d\udee0\ufe0f Advanced geemap Utilities","text":"Utility Description Code Example JS to Python Converts official GEE docs (JS) to Python <code>geemap.js_to_python(in_file, out_file)</code> Zonal Stats Calculate stats for thousands of polygons <code>geemap.zonal_stats(roi, image, stats_type='MEAN')</code> Time-Lapse Create animated GIFs of urban expansion <code>geemap.sentinel2_timelapse(roi, ...)</code> Split Map Compare two images side-by-side <code>Map.split_map(left_layer, right_layer)</code>"},{"location":"gee_geemap/#deep-dive-troubleshooting-the-cloud","title":"\u2753 Deep Dive: Troubleshooting the Cloud","text":"<p>Q: Why do I get \"Computed value is too large\" error? A: This happens when you try to use <code>.getInfo()</code> on a large object (like a global image). GEE prevents these large data transfers. Instead, Export the result to Google Drive.</p> <p>Q: My <code>Map.addLayer</code> is taking forever! A: Check if you have complex geometry (thousands of vertices). Try simplifying your geometry using <code>.simplify(10)</code> or reduce the number of images being processed simultaneously.</p> <p>Q: Can I use PyTorch models in GEE? A: Yes! This is an advanced workflow using Google AI Platform. You train the model locally, host it in the cloud, and GEE sends data to the model for real-time inference.</p> <p>Quota Limits</p> <p>GEE is free for research but has strictly enforced rate limits. Avoid putting <code>.getInfo()</code> inside a local Python <code>for</code> loop, as it will swamp the API and get you temporarily blocked.</p> <p>Next: Machine Learning &amp; Geospatial Intelligence \u00bb{ .md-button .md-button--primary }</p>"},{"location":"ml_geospatial/","title":"Machine Learning &amp; Deep Learning for Geospatial Intelligence","text":"<p>The intersection of Artificial Intelligence (AI) and Geographic Information Systems (GIS)\u2014often referred to as GeoAI\u2014is transforming how we map and monitor the earth. This guide provides a rigorous technical overview of implementing Machine Learning (ML) and Deep Learning (DL) workflows on geospatial datasets.</p>"},{"location":"ml_geospatial/#section-1-the-machine-learning-workflow-in-gis","title":"\ud83c\udfdb\ufe0f Section 1: The Machine Learning Workflow in GIS","text":"<p>Geospatial machine learning differs from traditional ML in one critical aspect: Spatial Autocorrelation. Data points are not independent; they are influenced by their neighbors.</p>"},{"location":"ml_geospatial/#11-supervised-learning-pixel-based-vs-object-based","title":"1.1 Supervised Learning: Pixel-Based vs. Object-Based","text":"<ul> <li>Pixel-Based: Treats every pixel as an independent sample. Fast but often results in a \"salt and pepper\" effect.</li> <li>Object-Based (OBIA): Groups pixels into homogeneous objects (segments) first, then classifies those segments. More realistic for forestry and urban mapping.</li> </ul>"},{"location":"ml_geospatial/#12-the-random-forest-deep-dive","title":"1.2 The Random Forest Deep Dive","text":"<p>Random Forest (RF) is the current industry champion for LULC (Land Use / Land Cover) classification.</p> How it WorksImplementation (Scikit-Learn) <p>RF builds hundreds of decision trees on random subsets of the data. The final class is decided by a majority vote. OOB (Out-of-Bag) Error*: An internal validation metric that estimates accuracy without needing a separate test set. *   Feature Importance**: Tells you which bands (e.g., Red-Edge or SWIR) were most critical for the classification.</p> <pre><code>from sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import classification_report, cohen_kappa_score\n\n# Hyperparameter Tuning\nmodel = RandomForestClassifier(\n    n_estimators=250, \n    max_features='sqrt',\n    min_samples_leaf=5,\n    n_jobs=-1 # Use all CPU cores\n)\n\nmodel.fit(X_train, y_train)\ny_pred = model.predict(X_test)\n\n# Accuracy Assessment\nprint(classification_report(y_test, y_pred))\nprint(f\"Kappa Score: {cohen_kappa_score(y_test, y_pred)}\")\n</code></pre>"},{"location":"ml_geospatial/#section-2-deep-learning-semantic-segmentation","title":"\ud83e\udde0 Section 2: Deep Learning &amp; Semantic Segmentation","text":"<p>When simple spectral patterns aren't enough (e.g., identifying swimming pools or ship types), we turn to Deep Learning.</p>"},{"location":"ml_geospatial/#21-the-u-net-architecture","title":"2.1 The U-Net Architecture","text":"<p>U-Net is the gold standard for semantic segmentation in satellite imagery. It features a \"contracting\" path to capture context and a \"symmetric expanding\" path that enables precise localization.</p>"},{"location":"ml_geospatial/#22-data-engineering-for-deep-learning","title":"2.2 Data Engineering for Deep Learning","text":"<p>Unlike tabular ML, Geospatial DL requires a complex data pipeline:</p> <ol> <li>Tiling: Splitting 10,000x10,000 images into 256x256 chips.</li> <li>Stretching: Rescaling 16-bit satellite data to 8-bit (0-255) for neural network compatibility.</li> <li>Augmentation: Randomly rotating and flipping chips to teach the model that a building is a building regardless of its orientation.</li> </ol> <pre><code># Conceptual PyTorch Dataset for GeoTIFFs\nclass GeoDataset(Dataset):\n    def __getitem__(self, index):\n        # Load image chip using rasterio\n        with rasterio.open(self.image_paths[index]) as src:\n            img = src.read().astype('float32') / 255.0\n        # Return image and mask\n        return torch.from_numpy(img), torch.from_numpy(mask)\n</code></pre>"},{"location":"ml_geospatial/#section-3-validation-uncertainty","title":"\ud83d\udcca Section 3: Validation &amp; Uncertainty","text":"<p>In Geospatial science, \"Accuracy\" is not enough. We must measure how the model performs across different spatial domains.</p>"},{"location":"ml_geospatial/#31-metrics-that-matter","title":"3.1 Metrics that Matter","text":"<ul> <li>IoU (Intersection over Union): Critical for segmentation. Measures how well predicted polygons overlap with ground truth.</li> <li>F1 Score: Balances precision (avoiding false alarms) and recall (avoiding missing targets).</li> <li>Confusion Matrix: Essential for identifying which classes (e.g., \"Forest\" vs \"Shrub\") the model is confusing.</li> </ul>"},{"location":"ml_geospatial/#32-spatial-cross-validation","title":"3.2 Spatial Cross-Validation","text":"<p>Standard random splitting of data often leads to \"overfitting\" because training and testing points are too close to each other.</p> <ul> <li>Buffer-based Splitting: Ensuring training and testing sets are separated by a minimum physical distance.</li> <li>Block Cross-Validation: Splitting the study area into geographic blocks.</li> </ul>"},{"location":"ml_geospatial/#section-4-advanced-geoai-architectures","title":"\ud83d\udd2c Section 4: Advanced GeoAI Architectures","text":"Architecture Use Case Popular Frameworks CNN (Standard) Scene classification (Is this an airport or a forest?) TensorFlow, PyTorch RNN / LSTM Time-series prediction (Predicting crop yield based on seasonal NDVI) Keras GANs Image-to-Image translation (Generating realistic optical imagery from SAR data) Solaris Vision Transformers Capturing long-range dependencies in global datasets Segformer"},{"location":"ml_geospatial/#professional-faq-ml-in-production","title":"\u2753 Professional FAQ: ML in Production","text":"<p>Q: How do I handle class imbalance (e.g., 90% forest, 1% water)? A: Use SMOTE (Synthetic Minority Over-sampling Technique) or apply Class Weights in your loss function. This forces the model to care more about the rare classes.</p> <p>Q: Can I use ML on unlabelled data? A: Yes! Use K-Means or Gaussian Mixture Models for initial exploration. This helps you identify natural spectral clusters before you spend time collecting ground truth.</p> <p>Q: Which is better: Python or GEE for ML? A: Use GEE for Random Forest on planetary scales. Use Python (local/Colab) for Deep Learning because GEE's internal support for neural networks is currently limited compared to PyTorch/TensorFlow.</p> <p>The Black Box Warning</p> <p>Machine Learning models can produce high accuracy but low scientific validity. Always check \"Feature Importance\" to ensure your model is making decisions for the right reasons (e.g., using spectral bands rather than artifacts in the data).</p> <p>Next: Guided Learning Curriculum \u00bb{ .md-button .md-button--primary }</p>"},{"location":"python_gis/","title":"Python for Geospatial Analysis: Comprehensive Mastery","text":"<p>Python is the undisputed leader in the geospatial coding world. Its ecosystem is vast, ranging from low-level geometry libraries to high-level data analysis frameworks. This guide provides a deep-dive into the \"Big Three\" of Python GIS: Vector, Raster, and Spatial Statistics.</p>"},{"location":"python_gis/#section-1-the-vector-foundation-point-line-polygon","title":"\ud83c\udfdb\ufe0f Section 1: The Vector Foundation (Point, Line, Polygon)","text":"<p>In geospatial science, vector data represents discrete features. These features are defined by their geometry and associated attributes.</p>"},{"location":"python_gis/#11-the-shapely-logic","title":"1.1 The Shapely Logic","text":"<p>At the heart of almost every Python GIS library is Shapely. It handles the Cartesian geometry logic. Understanding Shapely is critical because it explains how \"Point within Polygon\" or \"Intersection\" works mathematically.</p> <pre><code>from shapely.geometry import Point, Polygon\n\n# Define a point (Lon, Lat)\np1 = Point(85.8245, 20.2961) # Bhubaneswar, India\n\n# Define a simple polygon (square)\npoly = Polygon([(85.8, 20.2), (85.9, 20.2), (85.9, 20.3), (85.8, 20.3)])\n\n# Spatial Test\nis_inside = p1.within(poly)\nprint(f\"Is the point inside? {is_inside}\")\n</code></pre>"},{"location":"python_gis/#12-geopandas-dataframes-with-a-spatial-soul","title":"1.2 GeoPandas: DataFrames with a Spatial Soul","text":"<p>GeoPandas is where the real work happens. It allows you to perform SQL-like operations on geographic data.</p> Advanced Spatial JoinsCoordinate Reference Systems (CRS) <p>A spatial join (<code>sjoin</code>) merges data based on geographic location rather than a common ID.</p> <pre><code>import geopandas as gpd\n\n# Load administrative boundaries and hospital locations\ndistricts = gpd.read_file(\"districts.shp\")\nhospitals = gpd.read_file(\"hospitals.csv\") # Points\n\n# Perform the join\n# 'within' predicate ensures point is inside the polygon\nhospitals_with_district = gpd.sjoin(hospitals, districts, how=\"inner\", predicate='within')\n\n# Now you can calculate statistics per district\nhospital_count = hospitals_with_district.groupby('district_name').size()\n</code></pre> <p>One of the leading causes of error in GIS is mismatched CRS. A computer cannot calculate distance between Lon/Lat degrees (WGS84) accurately without projecting to meters (UTM).</p> <pre><code># Check current CRS\nprint(districts.crs)\n\n# Reproject to a local UTM zone for accurate area calculation (in sq meters)\ndistricts_utm = districts.to_crs(epsg=32645) # UTM Zone 45N\ndistricts['area_km2'] = districts_utm.area / 10**6\n</code></pre>"},{"location":"python_gis/#section-2-raster-processing-remote-sensing","title":"\ud83d\uddbc\ufe0f Section 2: Raster Processing &amp; Remote Sensing","text":"<p>Raster data is a grid of pixels, where each pixel contains a value (e.g., elevation, temperature, or reflectance).</p>"},{"location":"python_gis/#21-rasterio-the-low-level-powerhouse","title":"2.1 Rasterio: The Low-Level Powerhouse","text":"<p>Rasterio is the Python wrapper for GDAL. It is used for reading, writing, and masking raster files.</p> <pre><code>import rasterio\nfrom rasterio.plot import show\n\nwith rasterio.open('satellite_image.tif') as dataset:\n    # Read first band (Red)\n    red_band = dataset.read(1)\n\n    # Get metadata for writing new files\n    metadata = dataset.meta.copy()\n\n    # Calculate mask based on a threshold\n    water_mask = (red_band &lt; 500)\n</code></pre>"},{"location":"python_gis/#22-numerical-analysis-with-numpy","title":"2.2 Numerical Analysis with NumPy","text":"<p>Because rasters are just multi-dimensional arrays, we use NumPy for fast numerical computation.</p> NDVI CalculationTiling Large Images <p>Normalized Difference Vegetation Index (NDVI) is the \"Hello World\" of remote sensing.</p> <pre><code>import numpy as np\n\n# Read NIR and Red bands\nwith rasterio.open('image.tif') as src:\n    red = src.read(3).astype('float32')\n    nir = src.read(4).astype('float32')\n\n# Allow division by zero (avoid errors in water bodies)\nnp.seterr(divide='ignore', invalid='ignore')\n\n# Calculation\nndvi = (nir - red) / (nir + red)\n\n# Replace NaNs with zero\nndvi = np.nan_to_num(ndvi)\n</code></pre> <p>When an image is too large for RAM, we process it in windows (tiles).</p> <pre><code>from rasterio.windows import Window\n\nwith rasterio.open('massive_image.tif') as src:\n    # Define a 1024x1024 window starting at (0,0)\n    window = Window(0, 0, 1024, 1024)\n    subset = src.read(1, window=window)\n</code></pre>"},{"location":"python_gis/#section-3-spatial-statistics-neighborhood-analysis","title":"\ud83d\udcc8 Section 3: Spatial Statistics &amp; Neighborhood Analysis","text":"<p>Moving beyond simple geometry, we look at the relationships between features.</p>"},{"location":"python_gis/#31-kernel-density-estimation-kde","title":"3.1 Kernel Density Estimation (KDE)","text":"<p>Used to identify \"hotspots\" of occurrences (e.g., crime or disease clusters).</p> <pre><code>import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Using seaborn's internal KDE engine on point geometry\nsns.kdeplot(\n    data=gdf, x=gdf.geometry.x, y=gdf.geometry.y, \n    fill=True, cmap='viridis', thresh=0.05\n)\nplt.title(\"Spatial Hotspot Map\")\n</code></pre>"},{"location":"python_gis/#32-spatial-lag-autocorrelation-pysal","title":"3.2 Spatial Lag &amp; Autocorrelation (PySAL)","text":"<p>The first law of geography states: \"Everything is related to everything else, but near things are more related than distant things.\" We use PySAL to measure this.</p> <pre><code>from libpysal.weights import Queen\nimport esda\n\n# Create spatial weights (Who is a neighbor of whom?)\nw = Queen.from_dataframe(gdf)\n\n# Calculate Moran's I (Global Spatial Autocorrelation)\nmi = esda.moran.Moran(gdf['income'], w)\nprint(f\"Moran's I Statistic: {mi.I}\")\n</code></pre>"},{"location":"python_gis/#section-4-operationalizing-the-workflow","title":"\ud83d\udee0\ufe0f Section 4: Operationalizing the Workflow","text":""},{"location":"python_gis/#41-automated-environmental-setup","title":"4.1 Automated Environmental Setup","text":"<p>To ensure reproducibility, use this environment YAML file. Save it as <code>environment.yml</code> and run <code>conda env create -f environment.yml</code>.</p> <pre><code>name: geo_master\nchannels:\n  - conda-forge\ndependencies:\n  - python=3.10\n  - geopandas\n  - rasterio\n  - shapely\n  - pyproj\n  - libpysal\n  - esda\n  - leafmap\n  - fiona\n  - pycrs\n  - jupyterlab\n  - numpy\n  - pandas\n  - matplotlib\n  - seaborn\n</code></pre>"},{"location":"python_gis/#frequently-asked-questions-troubleshooting","title":"\u2753 Frequently Asked Questions (Troubleshooting)","text":"<p>Q: Why is my <code>sjoin</code> returning zero results? A: 99% of the time, this is a CRS mismatch. Ensure both GeoDataFrames have the same <code>crs</code> attribute before joining.</p> <p>Q: How do I handle 100GB+ of Imagery? A: Use Dask with Xarray. It allows for \"lazy loading,\" where the computer only reads pixels into memory when a final calculation is triggered.</p> <p>Q: My shapefile has \"Invalid Geometries,\" what do I do? A: Run <code>gdf['geometry'] = gdf.make_valid()</code>. This fixes self-intersecting loops and \"slivers.\"</p> <p>Conclusion</p> <p>Mastering Python for GIS is a superpower. It allows you to take raw geospatial data and turn it into predictive models, high-performance web maps, and rigorous scientific research.</p> <p>Next: Modern Geospatial Data Sources \u00bb{ .md-button .md-button--primary }</p>"},{"location":"tutorials/","title":"Geospatial Mastery: The Guided Learning Path","text":"<p>Mastering modern geospatial science requires more than just learning code; it requires a synthesis of geography, mathematics, and software engineering. This curriculum is designed to take you from a curious beginner to a professional Geospatial Data Architect.</p>"},{"location":"tutorials/#educational-methodology-the-tiered-approach","title":"\ud83c\udfdb\ufe0f Educational Methodology: The Tiered Approach","text":"<p>Our tutorials follow the \"Scaffolded Learning\" model. We provide the theoretical concepts, show you the core code, and then challenge you to apply those skills to real-world datasets.</p>"},{"location":"tutorials/#prerequisites-for-success","title":"Prerequisites for Success","text":"<p>To get the most out of this hub, you should have a basic understanding of:</p> <ul> <li>Fundamental GIS: Coordinate systems (WGS84 vs UTM), Projections, and Datums.</li> <li>Basic Python: Variables, lists, loops, and the <code>pandas</code> library.</li> <li>Statistics: Mean, Standard Deviation, and basic probabilities.</li> </ul>"},{"location":"tutorials/#level-1-foundations-of-spatial-programming","title":"\ud83d\udfe2 Level 1: Foundations of Spatial Programming","text":"<p>This module focuses on the local machine environment. You will learn to treat geographic data as structured, programmable objects rather than just \"layers.\"</p>"},{"location":"tutorials/#core-learning-objectives","title":"Core Learning Objectives","text":"<ol> <li>Environment Stability: Learn why <code>mamba</code> is the only way to reliably install libraries like <code>GDAL</code> and <code>Fiona</code>.</li> <li>Vector Algebra: Go beyond \"clipping\" and \"buffering\" in a GUI. Implement spatial joins, predicate logic, and geometry cleaning.</li> <li>Raster Math: Master the <code>numpy</code> backbone of spectral analysis. Calculate NDVI, NDWI, and NBR from first principles.</li> </ol> <p>Primary Module: Intro to Python GIS \u00bb</p>"},{"location":"tutorials/#level-2-cloud-native-analysis-at-scale","title":"\ud83d\udfe1 Level 2: Cloud-Native Analysis at Scale","text":"<p>Once you can process a single image locally, learn how to process ten thousand images in the cloud using Google Earth Engine (GEE).</p>"},{"location":"tutorials/#core-learning-objectives_1","title":"Core Learning Objectives","text":"<ol> <li>Functional Programming: Master <code>.map()</code> and <code>.reduce()</code>. Learn why the cloud hates standard Python <code>for</code> loops.</li> <li>Temporal Compositing: Create seamless, cloud-free mosaics of entire countries.</li> <li>Visualization Dashboards: Build interactive web applications using <code>geemap</code> that allow stakeholders to explore your data.</li> </ol> <p>Primary Module: Mastering Google Earth Engine \u00bb</p>"},{"location":"tutorials/#level-3-geospatial-intelligence-aiml","title":"\ud83d\udd34 Level 3: Geospatial Intelligence (AI/ML)","text":"<p>The final tier focuses on predictive analytics. Here, we transition from observing the world to predicting its future state.</p>"},{"location":"tutorials/#core-learning-objectives_2","title":"Core Learning Objectives","text":"<ol> <li>Advanced Classification: Train, validate, and prune Random Forest models. Handle class imbalance and measure feature importance.</li> <li>Computer Vision for GIS: Build deep learning pipelines (U-Net) to extract features like building footprints or ship tracks from multi-spectral imagery.</li> <li>Validation Rigor: Implement Spatial Cross-Validation to ensure your model generalizes across different geographic regions.</li> </ol> <p>Primary Module: AI &amp; Machine Learning \u00bb</p>"},{"location":"tutorials/#recommended-capstone-projects","title":"\ud83d\ude80 Recommended Capstone Projects","text":"<p>To solidify your learning, we suggest attempting one of the following \"Real World\" projects. Documentation for these will be added in our upcoming Case Studies section.</p>"},{"location":"tutorials/#project-a-urban-flood-susceptibility","title":"\ud83c\udf0a Project A: Urban Flood Susceptibility","text":"<p>Integrate Digital Elevation Models (DEM), rainfall data, and land cover to create a high-resolution flood risk map for a major city. Use Python for pre-processing and Random Forest for prediction.</p>"},{"location":"tutorials/#project-b-automated-change-detection","title":"\ud83c\udfd7\ufe0f Project B: Automated Change Detection","text":"<p>Use the GEE Sentinel-1 (Radar) and Sentinel-2 (Optical) archives to detect illegal deforestation or new urban sprawl in near real-time.</p>"},{"location":"tutorials/#project-c-heat-island-analysis","title":"\ud83c\udf21\ufe0f Project C: Heat Island Analysis","text":"<p>Use MODIS Land Surface Temperature (LST) data and building density vectors to measure the Urban Heat Island effect across a metropolitan region.</p>"},{"location":"tutorials/#resources-for-continued-learning","title":"\ud83d\udee0\ufe0f Resources for Continued Learning","text":"<p>Geospatial coding is a vast field. If you've finished the modules here, we recommend exploring:</p> <ul> <li>The Spatial Data Science Handbook: For deep statistical theory.</li> <li>Step-by-Step GEE Documentation: The official Google Earth Engine guides.</li> <li>The Open Geospatial Consortium (OGC): To understand the standards behind COGs and STAC.</li> </ul> <p>Final Encouragement</p> <p>\"Documentation is a love letter that you write to your future self.\" \u2014 Damian Conway. As you go through these tutorials, comment your code, track your versions on GitHub, and never stop questioning the spatial patterns you see.</p>   * :material-numeric-1-circle:{ .lg .middle } **Level 1: Foundations**      ---      Master the basics of data structures and environment setup.    * [Setting up Conda/Mamba](python_gis.md)   * [Introduction to GeoPandas](python_gis.md)   * [Basic Vector Operations](python_gis.md)  * :material-numeric-2-circle:{ .lg .middle } **Level 2: Cloud Computing**      ---      Transition your local workflows to the cloud for planetary scale.    * [Introduction to GEE](gee_geemap.md)   * [Sentinel-2 Data Exploration](gee_geemap.md)   * [Time-series Analysis](gee_geemap.md)  * :material-numeric-3-circle:{ .lg .middle } **Level 3: Advanced Intelligence**      ---      Integrate your spatial skills with predictive modeling.    * [Random Forest for LULC](ml_geospatial.md)   * [Unsupervised Clustering](ml_geospatial.md)   * [Statistical Modeling (PR/Logit)](ml_geospatial.md)"},{"location":"tutorials/#completion-guide","title":"\ud83d\udcc8 Completion Guide","text":"<p>Check off your achievements as you progress through the hub:</p> <ul> <li>[ ] Install local geospatial environment</li> <li>[ ] Create your first Buffer Map in Python</li> <li>[ ] Authenticate GEE on your machine</li> <li>[ ] Run a classification model on GEE</li> </ul> <p>Geospatial Wisdom</p> <p>\"The use of GIS is limited only by the imagination of those who use it.\" \u2014 Jack Dangermond</p>"}]}